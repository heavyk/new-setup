

### 2023-05-19 19:28 - music player idea

I really want to listen to music cause the stone is starting to rise and I want to write -- however I lost my old setup where I had this one albumn "filteria - living with the lag" (I forgot the real name, but it's similar) -- and when I played the song, I had (anotherr time when really stoned) adjusted the settings so that the sound is really different sounding; I lowered some freqs and raised some others, like seriah does (I was listening to "last exit for the lost" at the time) and I'd made the song sound completely different. I liked the way it sounded so much, I just left the song on repeat and listened to it prolly hundreds(?) of times.
  the thing is, I want to listen to it now but the last time I played it, it sounded terrible because it had all the wrong sound.
I don't remember right off what those specific sound settings were, but I have them saved in a local disk. I can try to see if I can get aimp settings out... soon
I think the best way to do it will be to start just doing it and not thinking about it.

there's actually this funny thing about foresight, which I feel like is a bit overlooked and I want to elaborate on that a moment first before fetching the settings, and that is
  I've been purposefully sabotaging myself in the past by saying the idea out loud, cause I know that if I just start doing without saying what I want outloud, I can produce it. I'm just letting everyone know that I'm not ignorant of my ways, but have been purposefully sabotaging myself. so, this is one of those "do as I say, not as I do" kind of things, where if you want to be successful and become really productive, *don't talk about your ideas until they're already built. inevitably it'll happen that I end up having to talk about the project I want to do, but when I do, it's because I'm implementing a part of it.
    I like the challenge of sabotaging myself though, because I'm constantly learning how to become more and more confident in myself. I don't actually feel ready for any of the stuff I'm going to be embarking on, and so for me the whole game is to sabotage myself until I'm actually feeling ready for everything. just a personal note there.
  what I like to do actually is not really think of the idea until I'm actually working on it, because in the process of working on it, I come to many new conclusions and realisations that I couldn't have come to if I was building the idea in m/ imagination.
  I'm not trying to convince anyone of this idea; I know it works, so if you want to do like I would be doing (if I felt ready), is to just work on my ideas while I'm in front of the computer and not really dream up ideas about what to do.
    the reality of a TODO list is that most of the ideas won't get done, so for me I put the things on the TODO list when they were ideas that I hadn't fully figured out how to do yet (I'm always trying to figure out new ways to do the things).
  
  therfore, I shall put forward a plan for how I shall do the project, which is to write it out, kind of like a journey -- and along the way I want to build all of the components as a sort of textual journey where I start with a bunch of markdown sources, I parse the files so that I can reference them from other places, then I take out all of the code blocks and concat each one into thir respective filename.ext for each of the code blocks. that's a cool idea.
if I sit down and I just do the next thing, what I've found is that I don't really "blow my mental load too early because mentally, I don't really know what I'm building until I get some of the code done.
I have a vague idea of what I'm coding, before I start, and then what ends up happening is I just start working.
  what happens to me here is that nosebook takes the idea and the way it feels to me in my head and then does something to it so that it kinda blocks my ability to re-access the concept in its seminal form.
  the second thing that happens after that is, because I have a large audience, that concept transforms A LOT; so much so that I end up having a difficult time myself accessing.
  then, once the idea has transformed enough, or nosebook has made the concept impossible to return to, it's gone; never to return to me in its original form; an evolution-of-desire.
  I can no longer return to the idea in it's original form, and now have to find a way to tune into the idea again in it's evolved form.
concepts change a lot, and to get a good output of a concept, it's important that I don't really experience the concept previously in my imagination or somewhere else, because it "aborts" the concept by forcing a transformation, or evolution on that idea
  an idea is an interesting thing, because all ideas are related to desire. every (creative) idea is founded on an underlying desire of why it should be there; be it experiencE or some other kind of external or internal signal modification (mind over matter, right?).
  in the end, every idea/concept we have about anything is built *on top* of a desire. therefore, from a conceptual standpoint, desire is the *lowest* in the hierarhy of things.
  when we know something, we have good desire of why itt's there (fear is a desire for something unwanted to happen with a concept built on top of what that fearsome thing looks like and how to avoid it, deal/struggle with it, etc.)
therefore, every idea ever rendered (made physical) into a medium is always *outdated*;
it's important to know that too because every single time that an idea gets "aborted", it's really getting transformed into a better version of itself.
  I am positively evidence for this, as I've been defeated in so many different ways, that I've had to evolve at such a rapid rate, the speed in which I can defeat myself  is, at this point a just a thtout a way.
  every single defeat causes a transformation; and that evolution is always for the better.
so, really what you want to do always is just sit down and start working on the vague idea in the moment and just let it come out naturally.
  this, is, positively, the, most, difficult, thing, to, explain, to, corporate execs, because they, want, the, meeting, so, they, can use their imaginations.
when I'm just building this thing (and that's why I'm choosing a documented approach; cause it's kind of more like a journey than a production), I'm just sorta having fun doing me.
  now, how to translate that idea into a social thing, where others can join in, I'm not totally sure, but it seems that's going to be a thing.
the way I want to do it is just to have a git repository with all 

hey, I just noticed I can probably just reuse a lot of that `zx` code there; they've got a lot of the functionality that I want already built in. the next thing I'd like to do is to build a vue is my own terminal. that'd be dope -- just use an array for the lines that way I can modify/etc. the lines as they're output. that'd be cool.

I totally distracted myself there, cause what I want to do is to build a vue based webaudio thing where I can listen (and perceive the sound), cause I'm going to want to produce a lot of js based on some (now unknown) language where I produce js files which transforms that audio signal. it'd be cool to also think about doing them in webassembly as well, as I think it'd be cool to output the code in normal wasm as well (super futuristic thinking for now).
  the idea is, to build a language that can "perceive" waves in audio, and then perform a sort of transformation on the signal. I'm *only* using it for audio, as I just want to make a cool song (one that repeats and I can listen to it over and over again), and then those transformations are what change the audio to accomplish (probably with mathematics) a new wavform, which is distinct from its original.
  eventually, this format will become highly marketable, because one can imagine that this style of programming can be sponsored by musicians and djs all over the place to produce better more dynamic versions of their song/mix -- and the "remix" is a code, and so therefore expertise is generated and people can purchase/buy/trade/sell better remix versions of that audio (trafsormed by this language).
    we'll design our own audio to such a precision that the "perfect" song can be created (some restrictions apply) and/or give it the ability to become dynamic, inputting and transforming signals from other sources like different physical sensors on the body, phone, microphone, camera, env, etc. (probably, because it's a bitmap, be aggregated and transformed first by shaders). audio in those spectrums will be visual, and then that visual data can then be used to transform the wav file (or whatever encoding builds the wav).
  really what I want to build is a technology that uses the senses and not the brain (in the non-traditional sense); what I want to do is to *listen to the same audio* in new ways. this really came out of that one song <filteria - living with the lag> cause I just like hearing it that way,
    it's kinda my theme song. the reason why I like sabotaging myself so much is because it's literally the *most novel experience* that one can possibly have. each time I "abort" m/ own thought by speaking it out or conjuring its feeling into my head while not working on it, I *force* an evolution on that desire. I *force* it to become something new and novvel in the sense that I had to discover it again.
    the thrill of that rediscovery is acttually exhilerating.
  so I want to add that to the repo as well.
so then the next thing is to load into webaudio that file...

```init.js

// init
// https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API

```

omg, I totally forgot, I should then find a way to use the content aware code sections in vscode. that's probably important. maybe also, I'll want to convert this app into a dot-net code, complete with the browser and everything -- like a real application, and not a sort of web application. I'm sure there's a way to use the v8 jit or whatever for the asm code (again futuristic thinking).

one of the things that I really want to be able to do is to build a number of commands out in a visual way,
  because I hate all of the --this and --that and want to just adjust the option
like imagine I'm turning a dial or something and I can just change the option like I would be able to on a hardware synth.
  it'd be really cool to render these directly into the canvas element using the write line/pixel (or even shaders) that build up the settings list (and give a visual feedback to the option such that those (shaders?) can get inputs from other bitmap output sources)
then, the obvious thing to do next is to string these commands together to perform larger tasks; for example, the very `built.md` will ensure all of the transformations on necessary files have been done (likely, some will be set to "run on demand", for only when the resource is needed)

omg, another thing that's really annoying me is using git. it's quite difficult for me, so one of the main uses of the vue commands, is to build a new way to use git (one that features all of the commands that *I* use).
  this is a really interesting thing about me (and possibly all humans), is that I like to see only the things that *I* want to see; until I have a need for a command I don't really want to see it.
  like, I want to just start out with the basic commands (the stuff you need only to get started), then to begin to add to my interface the things that I'm actually doing (and easily delete/archive them if I don't want/need them).
  so, for exaple in this case, if I can just run git commands like "rename branch" (just a button that turns into a textbox (I saw a vue example of it)) then I don't have to use the terminal. eventually, I want to get rid of the terminal entirely, getting feedback from the operations/systems  in a far more meaningful way that a line of text can convey (I'll consider that to be the "worst" result cause most of the stuff is unecessary info).
  these sorts of notifications are important for the safety and well-maintained system; you want to know when things aren't behaving properly and to be able to process the failure and parform a reaction to that.
    oh, that's an interesting monetisation goal there too because certain systems have to be run in a certain way, and so some companies will need to ensure that proper reactions are taken to the systems failures, and provide "official" and "trusted" reactions to the outputs.
    entire server installations will become automated in this way, and those source files will be the "trade secrets" of all of these different service infrastrutures. those platforms' source will become a commodity, and almost certainly barganined for and acquired with a sort of crypto currency or something. gatta have the enterprise edition, ya' know.
  so then we can imagine that each action produces a return code, where (0) returns the interface back to the home screen.

## progress

- js markdown. I remember that there was a thing that google had where there was a js and markdown thing
  - https://github.com/google/zx
  - [oh, that's awesome](https://raw.githubusercontent.com/google/zx/main/docs/markdown.md)
- get aimp settings out of disk
- add the filteria - living with the lag original .ogg file into the repository
- load file into webaudio and start building the thing
- import a lot of zx functionality into `built.md`, to compile all .md files into their corresponding filename.```ext blocks
- build a terminal in vue with the commands that I run often
  - import all of my .bashrc stuff here (like exporting env vars and stuff)
  - build a number of commands out in a visual way
  - build out `sh.0.md` and `sh.md`, where the sh is the shell panel, and sh.0 is the return code successful for a command executed in the shell (0)
    - this prompts me to consider that the unicode16 (W) style of format will want to be used, because I'm going to want to put actual expressions between the separators, to allow for `sh.>0.md` and even more complex stuff than that; all files qualities will be separated by a ., and they'll include binary data, to emoticons, to text, number and math function.
- throw this code away
