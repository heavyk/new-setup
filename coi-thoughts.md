# coi-thoughts

### 2023-09-024 07:46 - I don't think we're ready to launch yet

I'd like to take a moment to express some general opinions on the matter of coi-thoughts, and to do that I will use the example of "captain of industry". it's designed to be a multiplayer game (multiple people operating the same island), butt that feature isn't implemented yet, and is sort of a joke because it's antithesis to the idea of building up one's own personal factory on an *island*. that is, a an island can be seen something like a planet, and sovereign in that the island is a self-contained entity, and the barrier of the ocean/air separates that island from other land-masses. th, game intents to be selfish and serving to allow a person to create whatever they want in the configuration that they want, using the recipes available to them. this is very similar to software development, in more ways than one: when I use my compiler, I can use/write any syntax that I want to, so long as it outputs to a format that the machine running the code can respond to. a computer, like an island has a common set of inputs and outputs of various protocols (wood, rubber, sulfur, oil, etc.) and those items are interchanged with other islands, much like any netowork/human interface cards do.
  inside of the island, the way that the machines are organised and setup follows a set of conventions. for exam9le, I put my smelter slag on the inside of the dual smelter setup, so they can share a slag belt, but JD puts the exhaust on the inside. I find the single slag belt to be more efficient, especially for early game economics, because it isn't until later game when I get exhaust scrubbing, that having centre exhaust makes things easier (and having pipes for exhaust is easier to make diffitcult contortions than belts) so as a result my smelter builds use less belts and are a few tiles less wide. these conventions, are similar to code guidelines for software development. google has spent a lot of time figuring out the conventions used for the expression and connections of their machines/functons in their codebase, and it's been given a lot of thought into finding the best tradeoffs for speed/efficiency and clarity. inside of the island of google, all of the captains of that island need to adhere to the same conventions (blueprints) and string the machines/functionsx together in an acceptable and (best-effort) non-spaghetti like-way.
therefore captain of industry does not actually represent industry in a physical way, but in a *mental* way. the difference between the software and the hardware implementaton is that in hardware, the connection between parts is physical and defined by a protocol. each innovation improves the hardware, and more and more connections are possible because the protocol allows for more and more efficient/expanded/improved communication (hopefully). software is quite different than hardware because the connections that are made are *mental* and so therefore do not all adhere to the same protocol. software (like law) concerns itself with conditions, and the actions that are to take place under those cOnditions. therefore, each interface has room for misinterpretation, as it's often the case that one thing needed an improvement (more copper for example), so more machines were built, but maybe a belt forget to be upgraded, or it depended on another resource (like acid) which isn't in high enough supply to meet the demands -- which is like adding a new feature to a function, but it's a breaking API change, and somewhere, where that function is used, it's still assuming the old API (like an unupgraded belt).
  it is possible to make a finite set of resources which everyone can interchange effortlessly, like in coi (or other games), but that limits creativity to *only* being able to build things out of those primitive types (wood, steel, iron, rubber, etc.) much like math problems can be built using only certain primitive types (add,sub,mul,div,...) and so all more complex functions use some variant expression/combination/remix of those primitive typesx, to create something new. though, infinite, it's still a finite/linear intinite in comparison to the (chaotic world) of being able to do *anything*. coi is a symbolic (software) world, yet *real* industry is based in the physical world where all one needs is a desire do do something in physical, and there's *always* a way to do it.
another thing to note is exponentially increasing difficulty to make the next more complex system which also reflects software, but not hardware. in hardware things are finite and physically connected, making the infinite possible to realise. as an example: if I want I microprocessor to have 10 million times the specs that the one I'm writing this note on has, then I guarantee that it's possible, and I guarantee that it'll happen faster than the last 10000000X improvementt took to manifest. the reason for this is, is to move around units in 3d (like voltages or protons), they just need to be *caused* (that is desired/attratcted) to move there, and they find there way there, without fail. therefore, we (as creative 3d humans) just become more and more clever at *getting the results we want to see by adjusting physical conditions*.
  coi has (in my present perception) no way of implementing such an idea -- one where tthe physical (game world) reflects the desire of the creator. for example: if I want a storage container that has two input ports and output ports right next to eachother, I'd have the thing made, because *surely* someone else would want that container, and so therefore my product has value to them, and so therefore, they're willing to exchange something of value to them (usually money) in exchange for that better-fit physical part. this form of desire (altering shape/appearances) could be possible with cosmetics or something like that,-- but it doesn't have the capablitity (that I know of (besides a mod)) which offers entirely new functionality to the game.
what I'm looking for, is an idea that I created a long time ago, called "AliveScript" (and it's ridid form "alive-script") which is a programming language that is constantly a reflection of its code, where the syntax of the language that itself is built in (it starts by compiling itself), is dynamically expandable -- meaning that the syntax of the language itself is changing.
  this has important implications because the language itself is different than the code, and so when I say represent addition of a variable, no longer as "+=", it's now a little icon -- and when I see `y=mx+b` I see a graph (which updates as the values of the variables change, depending on the code's moment in "reality" (debug-breakpoint)). it's always running, but sometimes it pauses for introspection. when to introspect is determined by some set of (alarming/good) conditions, where action may or may not need to be made, and code updated. the system keeps running in the background. each of these snapshots/moments are saved, and as the code is changed, it swaps out instantly. all variables are observables and so code updates can happen any time. code is always running, and the interface *is* the code (running).
all features added are extensions of the language, as the language itself is included in every script/program -- which is always running. I suppose a program/script could be stopped, and I'm sure the operating system has an interface for that, but I'm only concerned with inputs+sytax+code=output loop that's always a reflection of its code. so, for example, let's say I want to change a function signature, all places that function are called are updated simultaneously, because they interface in the form of concepts (resonant ideas), and so dissonance between implementations is always resolved with more code (if condition do), so therefore there's never (lol) a time when same concepts are used incorrectly.
  as an example, if I say `y = printf(...)` and I want to change that code to be `printf(...)`, then all situations where that change can be made are done, however some places like `if (x = printf(...))` then those continue to use the printf concept that returns a value. only resonant (versions) of that function are used -- so what I have to do is to find a way to negate that return value, thereby changing the signature of the function: `if (y = printf(...)) { [... store y ...] }` -> `printf(...)` and so now all conditions that save the variable are changed. the reason this is possible is because both before and after (da igual el codigo) are the same concept: (output ... to screen). other variations my use sprintf (or whatevver,) but the concept is the same (diffrent implementations)

next, now that the program is conceptual, every concept will have a number of different im9lementations in many different languages/machines/bytecOde/etc. -- and there can be competing (best effort implementations/protocols for different conditions) where the implementation is dynamic and changing depending on some symbolic set of conditions (which machine/processor/abi/etc -- all the options/possibilities), and improvements on the implementations can be measured and verfied (the concept behaves in a defined/expected way under these conditions with this implementation), and so therefore there is a lot of room for new implementations to the same idea. all units of these AliveScripts are self-verified contained units. they come encrypted with the value of its concept, and so the concept and the expectations, *is* itself (which is the pure-desire form of expression: need -> want -> *I am* an expression/implementation of myself) -- and yet also an implementation of desire, because there are always going to be better versions of that concept than the one I presently am; I just haven't figured them out yet.

### 2023-09-24 09:00 - not ready to launch yet

the reason why I don't believe that we're ready to launch off just quite yet is because of attraction. "captain of industry" is a narrative creation of how the creators of the game perceive industry. the reason why this is important, is because it's what they're attracting. right now we live in a physical world where industry is getting *easier and easier* (all of the time, all of the time) -- and so what they're attracting for theirselves is a world in which hardware no longer is a physical/desire connection, but is now a mental one of increasing complexity because of increasing number of connections.
  the reason for this is simple: in software, each function interfaces with other functions (they get called by and return something to another function), and so each of of these connections has a sort of interface "cost" to it; that cost can be seen like resistance of electricity to pass through various media, such as a wire vs air. the interface has a membrane that allows things to pass through it, and if one thing has the magic key (secret passcode or *right* frequency), then passage is easy or even amplified, but if not, then passage is more difficult/resistant. in the same way, an event coming from the operating system (like me pressing the keys on the keyboard) will pass through the interface of a number of functions before it gets to the output interfaces (speakers/screen/joystick/etc). each interface that it passes through is analogous to one molecule in the air vibrating another at a speed in the perceptaable sound range -- and so it takes time for those frequency of vibraqtions to bump the next guy until it finally gets to the output medium where it has a density transion (solid surfaces or vacuum) where now my ears (or the feeling of my skin on the solid surface) can now sense/feel/hear the vibration. propagation speed is how fast it can transform/pass-off the message to the next bit, and the distance the message has to travel (number of hops) is directly related to complexity. each unit is connected to another set of units, and so therefore if there are 100 units and they each have connection to 10 others, then there are a lot of unique interfaces -- but if they connect to double that (20 others), then complexity significantly increases. it's not usual that 20 others happens spontaneously, but usually as a result of adding (10+ new units) -- meaning that now it's `110^20` vs `100^10` (obviously a much smaller number -- and my maths may not be correct, but the concept is right because I think it is not exponential but based on permutations -- which I can't conceptualise right now). in short, expanding a software team (new mentalities) or a codebase (new functions) increases cOmplexity at an alarming rate, whereas in physical, to expand anything is usually a *two dimensional* problem (`x^2`), and not a traveling salesperson.
    also btw, I want to become two dimensional, but only because it's the intermediate between 3d (physical) and 1d (plant/star/vector). and yes 0d is for the future -- as a centre where everything is relative to me -- which is still a "not yet" for me; too narrative and too "right way" still, because once I'm there, I'll hate it and then I want to prompty go -1d, which I can't comprehend yet -- other than inverse plant/star vector -- which is still incomprehensible -- ie, not yet; but eventually(tm).
