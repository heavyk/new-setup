# coi-thoughts

### 2023-09-024 07:46 - I don't think we're ready to launch yet

I'd like to take a moment to express some general opinions on the matter of coi-thoughts, and to do that I will use the example of "captain of industry". it's designed to be a multiplayer game (multiple people operating the same island), butt that feature isn't implemented yet, and is sort of a joke because it's antithesis to the idea of building up one's own personal factory on an *island*. that is, a an island can be seen something like a planet, and sovereign in that the island is a self-contained entity, and the barrier of the ocean/air separates that island from other land-masses. th, game intents to be selfish and serving to allow a person to create whatever they want in the configuration that they want, using the recipes available to them. this is very similar to software development, in more ways than one: when I use my compiler, I can use/write any syntax that I want to, so long as it outputs to a format that the machine running the code can respond to. a computer, like an island has a common set of inputs and outputs of various protocols (wood, rubber, sulfur, oil, etc.) and those items are interchanged with other islands, much like any netowork/human interface cards do.
  inside of the island, the way that the machines are organised and setup follows a set of conventions. for exam9le, I put my smelter slag on the inside of the dual smelter setup, so they can share a slag belt, but JD puts the exhaust on the inside. I find the single slag belt to be more efficient, especially for early game economics, because it isn't until later game when I get exhaust scrubbing, that having centre exhaust makes things easier (and having pipes for exhaust is easier to make diffitcult contortions than belts) so as a result my smelter builds use less belts and are a few tiles less wide. these conventions, are similar to code guidelines for software development. google has spent a lot of time figuring out the conventions used for the expression and connections of their machines/functons in their codebase, and it's been given a lot of thought into finding the best tradeoffs for speed/efficiency and clarity. inside of the island of google, all of the captains of that island need to adhere to the same conventions (blueprints) and string the machines/functionsx together in an acceptable and (best-effort) non-spaghetti like-way.
therefore captain of industry does not actually represent industry in a physical way, but in a *mental* way. the difference between the software and the hardware implementaton is that in hardware, the connection between parts is physical and defined by a protocol. each innovation improves the hardware, and more and more connections are possible because the protocol allows for more and more efficient/expanded/improved communication (hopefully). software is quite different than hardware because the connections that are made are *mental* and so therefore do not all adhere to the same protocol. software (like law) concerns itself with conditions, and the actions that are to take place under those cOnditions. therefore, each interface has room for misinterpretation, as it's often the case that one thing needed an improvement (more copper for example), so more machines were built, but maybe a belt forget to be upgraded, or it depended on another resource (like acid) which isn't in high enough supply to meet the demands -- which is like adding a new feature to a function, but it's a breaking API change, and somewhere, where that function is used, it's still assuming the old API (like an unupgraded belt).
  it is possible to make a finite set of resources which everyone can interchange effortlessly, like in coi (or other games), but that limits creativity to *only* being able to build things out of those primitive types (wood, steel, iron, rubber, etc.) much like math problems can be built using only certain primitive types (add,sub,mul,div,...) and so all more complex functions use some variant expression/combination/remix of those primitive typesx, to create something new. though, infinite, it's still a finite/linear intinite in comparison to the (chaotic world) of being able to do *anything*. coi is a symbolic (software) world, yet *real* industry is based in the physical world where all one needs is a desire do do something in physical, and there's *always* a way to do it.
another thing to note is exponentially increasing difficulty to make the next more complex system which also reflects software, but not hardware. in hardware things are finite and physically connected, making the infinite possible to realise. as an example: if I want I microprocessor to have 10 million times the specs that the one I'm writing this note on has, then I guarantee that it's possible, and I guarantee that it'll happen faster than the last 10000000X improvementt took to manifest. the reason for this is, is to move around units in 3d (like voltages or protons), they just need to be *caused* (that is desired/attratcted) to move there, and they find there way there, without fail. therefore, we (as creative 3d humans) just become more and more clever at *getting the results we want to see by adjusting physical conditions*.
  coi has (in my present perception) no way of implementing such an idea -- one where tthe physical (game world) reflects the desire of the creator. for example: if I want a storage container that has two input ports and output ports right next to eachother, I'd have the thing made, because *surely* someone else would want that container, and so therefore my product has value to them, and so therefore, they're willing to exchange something of value to them (usually money) in exchange for that better-fit physical part. this form of desire (altering shape/appearances) could be possible with cosmetics or something like that,-- but it doesn't have the capablitity (that I know of (besides a mod)) which offers entirely new functionality to the game.
what I'm looking for, is an idea that I created a long time ago, called "AliveScript" (and it's ridid form "alive-script") which is a programming language that is constantly a reflection of its code, where the syntax of the language that itself is built in (it starts by compiling itself), is dynamically expandable -- meaning that the syntax of the language itself is changing.
  this has important implications because the language itself is different than the code, and so when I say represent addition of a variable, no longer as "+=", it's now a little icon -- and when I see `y=mx+b` I see a graph (which updates as the values of the variables change, depending on the code's moment in "reality" (debug-breakpoint)). it's always running, but sometimes it pauses for introspection. when to introspect is determined by some set of (alarming/good) conditions, where action may or may not need to be made, and code updated. the system keeps running in the background. each of these snapshots/moments are saved, and as the code is changed, it swaps out instantly. all variables are observables and so code updates can happen any time. code is always running, and the interface *is* the code (running).
all features added are extensions of the language, as the language itself is included in every script/program -- which is always running. I suppose a program/script could be stopped, and I'm sure the operating system has an interface for that, but I'm only concerned with inputs+sytax+code=output loop that's always a reflection of its code. so, for example, let's say I want to change a function signature, all places that function are called are updated simultaneously, because they interface in the form of concepts (resonant ideas), and so dissonance between implementations is always resolved with more code (if condition do), so therefore there's never (lol) a time when same concepts are used incorrectly.
  as an example, if I say `y = printf(...)` and I want to change that code to be `printf(...)`, then all situations where that change can be made are done, however some places like `if (x = printf(...))` then those continue to use the printf concept that returns a value. only resonant (versions) of that function are used -- so what I have to do is to find a way to negate that return value, thereby changing the signature of the function: `if (y = printf(...)) { [... store y ...] }` -> `printf(...)` and so now all conditions that save the variable are changed. the reason this is possible is because both before and after (da igual el codigo) are the same concept: (output ... to screen). other variations my use sprintf (or whatevver,) but the concept is the same (diffrent implementations)

next, now that the program is conceptual, every concept will have a number of different im9lementations in many different languages/machines/bytecOde/etc. -- and there can be competing (best effort implementations/protocols for different conditions) where the implementation is dynamic and changing depending on some symbolic set of conditions (which machine/processor/abi/etc -- all the options/possibilities), and improvements on the implementations can be measured and verfied (the concept behaves in a defined/expected way under these conditions with this implementation), and so therefore there is a lot of room for new implementations to the same idea. all units of these AliveScripts are self-verified contained units. they come encrypted with the value of its concept, and so the concept and the expectations, *is* itself (which is the pure-desire form of expression: need -> want -> *I am* an expression/implementation of myself) -- and yet also an implementation of desire, because there are always going to be better versions of that concept than the one I presently am; I just haven't figured them out yet.
